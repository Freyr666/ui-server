open Topology
open Containers

type id = int [@@deriving yojson, show, eq, ord]

(** Legacy ID *)
type id' =
  | Single
  | T2mi_plp of int
  | Dvb of int * int
  | Unknown of int32 [@@deriving show, eq, ord]

let id_of_int32 : int32 -> id' = function
  | 0l -> Single
  | x when Int32.equal (Int32.logand x (Int32.of_int 0xFFFF0000)) Int32.zero
    -> let x'     = Int32.to_int x in
       let stream = (x' land 0x0000FF00) lsr 8 in
       let plp    = (x' land 0xFF) in
       (match stream with
        | 1             -> T2mi_plp plp
        | 2 | 3 | 4 | 5 -> Dvb (stream - 2, plp)
        | _             -> Unknown x)
  | _ as x -> Unknown x

let id_to_int32 : id' -> int32 = function
  | Single -> 0l
  | T2mi_plp plp ->
     1 lsl 8
     |> Int32.of_int
     |> Int32.logor (Int32.of_int plp)
  | Dvb (stream,plp) ->
     (2 + stream) lsl 8
     |> Int32.of_int
     |> Int32.logor (Int32.of_int plp)
  | Unknown x -> x

(** Stream source description/parameters *)
module Source = struct

  let round_freq (x:int64) =
    let ( mod ), ( / ), (=) = Int64.(rem, div, equal) in
    if x mod 1_000_000_000L  = 0L then x / 1_000_000_000L, "ГГц"
    else if x mod 1_000_000L = 0L then x / 1_000_000L, "МГц"
    else if x mod 1_000L     = 0L then x / 1_000L, "кГц"
    else x, "Гц"

  (** DVB-T2 source description *)
  type dvb_t2 =
    { freq : int64
    ; plp  : int
    ; bw   : float
    } [@@deriving yojson, show, eq, ord]

  (** DVB-T source description *)
  type dvb_t =
    { freq : int64
    ; bw   : float
    } [@@deriving yojson, show, eq, ord]

  (** DVB-C source description *)
  type dvb_c = dvb_t [@@deriving yojson, show, eq, ord]

  (** T2-MI source description *)
  type t2mi =
    { stream_id : int
    ; plp       : int
    } [@@deriving yojson, show, eq, ord]

  (** IP v4 source description *)
  type ipv4 =
    { scheme : string
    ; addr   : Ipaddr_ext.V4.t
    ; port   : int
    } [@@deriving yojson, show, eq, ord]

  (** Source desciption type *)
  type t =
    | DVB_T2 of dvb_t2
    | DVB_T  of dvb_t
    | DVB_C  of dvb_c
    | IPV4   of ipv4
    | ASI
    | SPI
    | T2MI   of t2mi [@@deriving yojson, show, eq, ord]

  let dvb_t2_to_string (x:dvb_t2) =
    let open Printf in
    let freq, unit = round_freq x.freq in
    let bw = sprintf "полоса %g МГц" x.bw in
    sprintf "DVB-T2, %Lu %s, %s, PLP %d" freq unit bw x.plp

  let dvb_t_to_string (x:dvb_t) =
    let open Printf in
    let freq, unit = round_freq x.freq in
    let bw = sprintf "полоса %g МГц" x.bw in
    sprintf "DVB-T, %Lu %s, %s" freq unit bw

  let dvb_c_to_string (x:dvb_c) =
    dvb_t_to_string x

  let asi_to_string () =
    "ASI"

  let spi_to_string () =
    "SPI"

  let t2mi_to_string (x:t2mi) =
    let open Printf in
    sprintf "T2-MI Stream ID: %d, PLP %d" x.stream_id x.plp

  let ipv4_to_string (x:ipv4) =
    Uri.make
      ~scheme:x.scheme
      ~host:(Ipaddr_ext.V4.to_string x.addr)
      ~port:x.port
      ()
    |> Uri.to_string

  let to_string = function
    | DVB_T2 x -> dvb_t2_to_string x
    | DVB_T  x -> dvb_t_to_string x
    | DVB_C  x -> dvb_c_to_string x
    | ASI      -> asi_to_string ()
    | SPI      -> spi_to_string ()
    | T2MI   x -> t2mi_to_string x
    | IPV4   x -> ipv4_to_string x

end

(** Multi TS ID *)
module Multi_TS_ID = struct

  type t = int32 [@@deriving yojson, eq, show, ord]

  type parsed =
    { source_id : int
    ; stream_id : int
    }

  (** Parse ID *)
  let to_parsed (t:t) : (parsed, string) result =
    Error "FIXME implement"

  (** Returns ID as it is defined in board exchange protocols *)
  let of_parsed (x:parsed) : t =
    failwith "FIXME implement"

  (** Returns raw ID as it is transmitted in a multi stream *)
  let of_parsed_raw (x:parsed) : t =
    failwith "FIXME implement"

end

type stream_type =
  | TS
  | T2MI [@@deriving yojson, eq, show, ord]

type tsoip_id =
  { addr : Ipaddr_ext.V4.t
  ; port : int
  } [@@deriving yojson, eq, show, ord]

type container_id =
  | TS_raw
  | TS_multi of Multi_TS_ID.t
  | TSoIP    of tsoip_id [@@deriving yojson, eq, show, ord]

let tsoip_id_of_url (x:Url.t) : tsoip_id =
  { addr = x.ip
  ; port = x.port
  }

module Raw = struct

  type t =
    { source  : source
    ; typ     : stream_type
    ; orig_id : container_id
    }
  and source_node =
    | Port   of int
    | Board
    | Stream of container_id
  and source =
    { node : source_node
    ; info : Source.t
    } [@@deriving eq, show]

end

type t =
  (* stream source node and description *)
  { source  : source
  (* unique generated stream id. just a numeric representation of source *)
  ; id      : id
  (* stream type *)
  ; typ     : stream_type
  (* original container id *)
  ; orig_id : container_id
  }
and source_node =
  | Entry  of topo_entry (* stream from input or generated by a board*)
  | Stream of t          (* stream extracted from another stream *)
and source =
  { node : source_node   (* source node *)
  ; info : Source.t      (* details about stream source *)
  } [@@deriving yojson, eq, show, ord]

let make_id (src:source) : id =
    Hashtbl.hash src

let to_multi_id (t:t) : Multi_TS_ID.t =
  match t.orig_id with
  | TS_multi x -> x
  | _          -> failwith "not a multi TS"

let typ_to_string = function
  | TS   -> "ts"
  | T2MI -> "t2mi"
let typ_of_string = function
  | "ts"   -> TS
  | "t2mi" -> T2MI
  | _      -> failwith "bad typ string"

let rec equal l r = l.id = r.id

let rec get_input (s:t) : topo_input option =
  match s.source.node with
  | Stream s      -> get_input s
  | Entry Input i -> Some i
  | Entry Board _ -> None

let to_topo_port (b:topo_board) (t:t) : topo_port option =
  let input = get_input t in
  let rec get_port input = function
    | []    -> None
    | hd :: tl ->
       (match hd.child with
        | Input x -> if equal_topo_input x input
                     then Some hd else get_port input tl
        | Board x -> (match get_port input x.ports with
                      | Some _ -> Some hd
                      | None   -> get_port input tl))
  in
  Option.flat_map (fun x -> get_port x b.ports) input
